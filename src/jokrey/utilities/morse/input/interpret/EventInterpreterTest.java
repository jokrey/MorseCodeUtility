package jokrey.utilities.morse.input.interpret;

import jokrey.utilities.morse.BinarySignalUnit;
import jokrey.utilities.morse.input.ActiveInputsOverTimeInputReceiver;
import jokrey.utilities.morse.input.PureInputReceiver;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

public class EventInterpreterTest {

    /**
     * Run pure tests where input output has been generated by the interpreter's alphabet
     */
    public static void run_sure_universal_tests(EventInterpreter interpreter) {
        String[] test_cases = {
                "hallo", "What are you talking boat?", "Canadians. Duh", "Hello this is a test.", "Again", "A Test....", "No the entire sentence, dumbo", "Why would I do that?", //should be able to detect natural language diversity
                "abcdefghijklmnopqrstuvwxyz0123456789",                  //every possible letter in sequence should definitly be easily detected
                "0123456789",
                "05",
                "ete",
                /*"eee", "ttt", "0", "5"*/ // could not all be detected - the scanner will either say 'eee' or 'ttt' on both.
                };

        for(String test_case:test_cases) {
            BinarySignalUnit[] signals = interpreter.alphabet.getSignalSpaceSequenceFor(test_case.toLowerCase());
            LinkedList<Double> signals_but_as_doubles = new LinkedList<>();
            Boolean currently_signal = null;
            double current_length = 0;
            for(BinarySignalUnit signal:signals) {
                if(currently_signal==null) {
                    currently_signal = signal.isSignal;
                    current_length+=signal.length;
                } else if(currently_signal == signal.isSignal) {
                    current_length+=signal.length;
                } else {
                    signals_but_as_doubles.add(current_length);
                    currently_signal = signal.isSignal;
                    current_length=signal.length;
                    assertEquals(currently_signal, signals_but_as_doubles.size() % 2 == 0); // make sure the calculation is correct. It's essentially testing the test, which is nothing I'd ever thought I'd do.
                }
            }
            signals_but_as_doubles.add(current_length);
            signals_but_as_doubles.add(3.0);

//            System.out.println("\""+test_case+"\" is: \""+BinarySignalUnit.getAsString(signals)+"\"");
//            System.out.println("\""+test_case+"\" is: \""+Arrays.toString(signals)+"\"");
//            System.out.println("\""+test_case+"\" is: \""+signals_but_as_doubles+"\"");
//            System.out.println("signals.l: "+signals.length);
//            System.out.println("signals_but_as_doubles.l: "+signals_but_as_doubles.size());

            pure_test(interpreter, signals_but_as_doubles, test_case, test_case.toLowerCase());
        }
    }
    /**
     * Every second 'pure_input_switch_wait_time' is interpreted as a pause. The first one is a signal.
     */
    public static void pure_test(EventInterpreter interpreter, List<Double> pure_input_switch_wait_times, String... possibleOutputs) {
        PureInputReceiver pure = new PureInputReceiver();

        for(int i=0;i<pure_input_switch_wait_times.size();i+=2) {
            pure.addNewInput_signal(pure_input_switch_wait_times.get(i));
            if(i+1<pure_input_switch_wait_times.size())
                pure.addNewInput_pause(pure_input_switch_wait_times.get(i+1));
        }

        interpreter.setEventsFrom(pure);
        String interpreter_output = interpreter.getAnalysisResult();
        if(!Arrays.asList(possibleOutputs).contains(interpreter_output)) {
            if(!Arrays.asList(possibleOutputs).contains(interpreter_output.replaceAll(" ", "")))
                fail("Interpreter("+interpreter.getClass().getName()+") failed to correctly interpret something allegedly pure:\nfrom: "+pure_input_switch_wait_times+"\nto: \""+interpreter_output+"\"\nbut expected one of: "+ Arrays.toString(possibleOutputs));
            else
                System.err.println("Interpreter("+interpreter.getClass().getName()+") interpreted "+interpreter_output+" which contains unexpected spaces");
        }
    }




    public static void active_input_short_test(EventInterpreter interpreter, long short_signal, long long_signal) {
        try {
            ActiveInputsOverTimeInputReceiver aiot_ir = new ActiveInputsOverTimeInputReceiver();

            //an 'h', but cannot be differentiated from 'tttt' or 'eeee' at this point.
            for(int i=0;i<4;i++) {
                signal_pause(aiot_ir, short_signal);
                short_signal(aiot_ir, short_signal);
            }

            letter_pause(aiot_ir, long_signal);

            //an 'a'
            short_signal(aiot_ir, short_signal);
            signal_pause(aiot_ir, short_signal);
            long_signal(aiot_ir, long_signal);

            interpreter.setEventsFrom(aiot_ir);
            assertEquals("ha", interpreter.getAnalysisResult());

            letter_pause(aiot_ir, long_signal); //shows that presumptuous interpretation already works instantly without pause. But before the next letter it is obviously required.

            //two 'l'
            for(int i=0;i<2;i++) {
                short_signal(aiot_ir, short_signal);
                signal_pause(aiot_ir, short_signal);
                long_signal(aiot_ir, long_signal);
                signal_pause(aiot_ir, short_signal);
                short_signal(aiot_ir, short_signal);
                signal_pause(aiot_ir, short_signal);
                short_signal(aiot_ir, short_signal);
                letter_pause(aiot_ir, long_signal);
            }

            interpreter.setEventsFrom(aiot_ir);
            assertEquals("hall", interpreter.getAnalysisResult());

            letter_pause(aiot_ir, long_signal);

            long_signal(aiot_ir, long_signal);
            signal_pause(aiot_ir, short_signal);
            long_signal(aiot_ir, long_signal);
            signal_pause(aiot_ir, short_signal);
            long_signal(aiot_ir, long_signal);

            interpreter.setEventsFrom(aiot_ir);
            assertEquals("hallo", interpreter.getAnalysisResult());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    private static void short_signal(ActiveInputsOverTimeInputReceiver aiot_ir, long short_signal) throws InterruptedException {
        aiot_ir.addInput_active();
        Thread.sleep(short_signal);
        aiot_ir.addInput_inactive();
    }
    private static void long_signal(ActiveInputsOverTimeInputReceiver aiot_ir, long long_signal) throws InterruptedException {
        aiot_ir.addInput_active();
        Thread.sleep(long_signal);
        aiot_ir.addInput_inactive();
    }
    private static void signal_pause(ActiveInputsOverTimeInputReceiver aiot_ir, long short_signal) throws InterruptedException {
        Thread.sleep(short_signal);
    }
    private static void letter_pause(ActiveInputsOverTimeInputReceiver aiot_ir, long long_signal) throws InterruptedException {
        Thread.sleep(long_signal);
    }


    public static void outlier_are_ignored_test(EventInterpreter interpreter, long short_signal, long long_signal) {
            try {
                ActiveInputsOverTimeInputReceiver aiot_ir = new ActiveInputsOverTimeInputReceiver();

                //an 'h', but cannot be differentiated from 'tttt' or 'eeee' at this point.
                for(int i=0;i<4;i++) {
                    signal_pause(aiot_ir, short_signal);
                    short_signal(aiot_ir, short_signal);
                }

                letter_pause(aiot_ir, long_signal);

                //an 'a'
                short_signal(aiot_ir, short_signal);
                signal_pause(aiot_ir, short_signal);
                long_signal(aiot_ir, long_signal);

                interpreter.setEventsFrom(aiot_ir);
                assertEquals("ha", interpreter.getAnalysisResult());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
    }
}